# generated by: rails generate scaffold_controller Schema
class TablesController < ApplicationController
  before_action :set_table, only: [:show, :update, :destroy, :trigger_dates]

  # GET /tables
  def index
    schema_id = params.require(:schema_id)                                      # should only list tables of specific schema
    check_user_for_valid_schema_right(schema_id)

    @tables = Table.all_allowed_tables_for_schema(schema_id, @current_user.db_user)
    render json: @tables
  end

  # GET /tables/1
  def show
    render json: @table
  end

  # GET /trigger_dates/1
  def trigger_dates
    dates = @table.youngest_trigger_change_dates_per_operation
    render json: {youngest_insert_trigger_changed_at: dates['I'], youngest_update_trigger_changed_at: dates['U'], youngest_delete_trigger_changed_at: dates['D']}
  end

  # POST /tables
  def create
    table_params.require([:schema_id, :name])
    check_user_for_valid_schema_right(table_params[:schema_id].to_i)

    tables = Table.where({ schema_id: table_params[:schema_id], name: table_params[:name]})   # Check for existing hidden or not hidden table
    if tables.length > 0                                                        # table still exists
      @table = tables[0]
      save_result = @table.update(table_params.to_h.merge({yn_hidden: 'N'}))    # mark visible for GUI
    else
      @table = Table.new(table_params)
      save_result = @table.save
    end

    if save_result
      log_activity(
          schema_name:  @table.schema.name,
          table_name:   @table.name,
          action:       "table inserted: #{@table.attributes}"
      )
      render json: @table, status: :created, location: @table
    else
      render json: { errors: @table.errors.full_messages }, status: :unprocessable_entity
    end
  end

  # PATCH/PUT /tables/1
  def update
    table_params.require(:lock_version)    # Ensure that column lock_version is sent as param from client
    if @table.update(table_params)
      log_activity(
          schema_name:  @table.schema.name,
          table_name:   @table.name,
          action:       "table updated: #{@table.attributes}"
      )
      render json: @table
    else
      render json: { errors: @table.errors.full_messages }, status: :unprocessable_entity
    end
  end

  # DELETE /tables/1
  def destroy
    table_params.require(:lock_version)    # Ensure that column lock_version is sent as param from client
    @table.update(yn_hidden: 'Y')
    log_activity(
        schema_name:  @table.schema.name,
        table_name:   @table.name,
        action:       "table marked hidden: #{@table.attributes}"
    )
  end

  private
  # Use callbacks to share common setup or constraints between actions.
  def set_table
    @table = Table.find(params[:id])
    check_user_for_valid_schema_right(@table.schema_id)
  end

  # Only allow a trusted parameter "white list" through.
  def table_params
    params.fetch(:table, {}).permit(:schema_id, :name, :info, :topic, :kafka_key_handling, :fixed_message_key, :lock_version)
  end


end
