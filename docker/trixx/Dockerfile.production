# aufzurufen aus dem Projekt-Root
# docker build -f docker/trixx/Dockerfile.production --build-arg BUILD_VERSION=`date "+%Y-%m-%d_%H-%M-%S"` -t trixx-docker-prod .
# docker run --rm -p 8080:8080 -e TRIXX_DB_PASSWORD=test -e SECRET_KEY_BASE=trixx trixx-docker-prod

# STAGE 1: build trixx frontend
FROM node:12-alpine AS frontend_build

ENV FRONTEND_SRC_PATH=frontend

RUN apk update && apk upgrade && \
    npm install -g @vue/cli

WORKDIR /app

COPY $FRONTEND_SRC_PATH/package*.json ./

RUN npm install

COPY $FRONTEND_SRC_PATH .

RUN npm run build

# STAGE 2: build trixx backend
FROM jruby:9.2.8.0

MAINTAINER Peter.Ramm@ottogroup.com

ENV BACKEND_SRC_PATH=.

RUN  apt-get update && \
     apt-get -y upgrade && \
     apt-get install -y procps git vim && \
     sh -c "echo 'Europe/Berlin' > /etc/timezone" && \
     sh -c "rm /etc/localtime && ln -s /usr/share/zoneinfo/Europe/Berlin /etc/localtime" && \
     dpkg-reconfigure -f noninteractive tzdata && \
     gem install bundler

WORKDIR /app

COPY ${BACKEND_SRC_PATH}/Gemfile* ./

RUN bundle config set deployment 'true' && \
    bundle install --jobs 4

COPY ${BACKEND_SRC_PATH} .

# Copy Frontend-Build into Rails-Project for static serve
COPY --from=frontend_build /app/dist public/

# use ARG not before this point, because ARGs are implicitly used by RUN commands and
# this will force docker cache misses which results in not using cached layers
ARG BUILD_VERSION
RUN (test -n "$BUILD_VERSION"  && echo $BUILD_VERSION || date "+%Y-%m-%d_%H-%M-%S") > /app/build_version

EXPOSE 8080/tcp

# use bracket syntax to ensure run-kafka-jruby.sh runs with PID 1 and receives SIGTERM signal
CMD ["/app/docker/trixx/run-trixx-sandro.sh"]